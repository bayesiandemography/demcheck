
#' Checks of composite conditions
#'
#' Functions to check for conditions that involve
#' several attributes. For instance, \code{chk_is_integer_consec}
#' checks whether \code{x} has type integer, whether \code{x}
#' has no \code{NA}s, and whether \code{all(diff(x)) == 1L}.
#'
#' \code{chk_is_first_day_unit} checks whether a \code{x}
#' consists of first days for the time unit supplied,
#' eg values such \code{"2001-03-01"}, \code{"2001-05-01"}, or
#' \code{"2000-09-01"} when \code{unit} is \code{"months"}.
#' \code{chk_is_first_day_unit_consec} adds the condition
#' that these dates be consecutive, eg
#' \code{"2001-03-01"}, \code{"2001-04-01"}, \code{"2000-09-01"}.
#' Separately checking for first days makes the job of
#' \code{chk_is_first_day_unit_consec} much easier, which
#' is why we have two functions.
#'
#' Most of the functions raise an error if \code{x} has \code{NA}s.
#' 
#' @param x The object being checked.
#' @param x1 The first of a pair of objects being checked.
#' @param x2 The second of a pair of objects being checked.
#' @param name The name used in any message. Typically,
#' but not always, the name of \code{x}.
#' @param names Dimension names.
#' @param name1 The name of the first of the pair of objects.
#' @param name2 The name of the second of the pair of objects.
#' @param unit Measurement units for time, eg \code{"month"}.
#' @param age Age, typically in years, but can be other unit.
#' @param class Name of class.
#' @param break_min Lowest value for breaks.
#' @param break_max Highest value for breaks.
#' @param date Date on which event occurred or measurement made.
#' Object of class "Date".
#' @param dob Date of birth. Object of class "Date".
#' @param null_ok Whether to allow \code{NULL}.
#' @param n An integer.
#' @param month_start An abbreviated month name,
#' as generated by \code{\link[base]{month.abb}}.
#' @param width The width of multi-year age groups or periods.
#' @param origin A year used to define multi-year periods.
#' @param labels Dimension labels: the \code{i}th element of \code{dimnames}
#' @param dimtype Character. The dimtype of the dimension.
#' @param dimtypes Character. The dimtypes of the dimensions.
#'
#' @return When \code{x} passes the test,
#' the \code{chk*} and \code{err*} functions both
#' return \code{TRUE}.  When \code{x} fails the test,
#' the \code{chk*} functions return a string, and the \code{err*}
#' functions raise an error.
#'
#' @seealso \code{\link{single}}, \code{\link{member}}
#' @name composite
NULL


## HAS_TESTS
## all elements of vector inherit from specified class
#' @export
#' @rdname composite
chk_all_class <- function(x, name, class) {
    for (i in seq_along(x)) {
        if (!methods::is(x[[i]], class))
            return(gettextf(paste("element %d of '%s' has class \"%s\" :",
                                  "should instead inherit from class \"%s\""),
                            i, name, class(x[[i]]), class))
    }
    TRUE
}

## HAS_TESTS
## array has metadata required to uniquely identify
## every cell, using only dimnames and names of
## dimnames
#' @export
#' @rdname composite
chk_array_metadata_complete <- function(x, name) {
    val <- chk_has_dimnames(x = x,
                            name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_has_names_dimnames(x = x,
                                  name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_names_dimnames_complete(x = x,
                                       name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_dimnames_complete(x = x,
                                 name = name)
    if (!isTRUE(val))
        return(val)
    TRUE
}


## HAS_TESTS
#' @export
#' @rdname composite
chk_character_complete <- function(x, name) {
    if (any(is.na(x)))
        return(gettextf("'%s' has NAs",
                        name))
    if (!all(nzchar(x)))
        return(gettextf("'%s' has blanks",
                        name))
    is_duplicated <- duplicated(x)
    if (any(is_duplicated)) {
        i <- match(TRUE, is_duplicated)
        return(gettextf("'%s' has duplicate [\"%s\"]",
                        name, x[[i]]))
    }
    TRUE
}


## HAS_TESTS
#' @export
#' @rdname composite
chk_categories_complete <- function(x, name) {
    if (any(is.na(x)))
        return(gettextf("'%s' has NAs",
                        name))
    if (!all(nzchar(x)))
        return(gettextf("'%s' has blanks",
                        name))
    is_duplicated <- duplicated(x)
    i <- match(TRUE, is_duplicated, nomatch = 0L)
    if (i > 0L) {
        return(gettextf("'%s' has duplicate [\"%s\"]",
                        name, x[[i]]))
    }
    TRUE
}


## HAS_TESTS
#' @export
#' @rdname composite
chk_date_consistent_with_month_start <- function(x, name, month_start) {
    x_month <- format(x, format = "%b")
    if (!identical(x_month, month_start)) {
        month_start_full <- month.name[match(month_start, month.abb)]
        x_month_full <- format(x, format = "%B")
        return(gettextf(paste("'%s' [\"%s\"] implies that year starts in %s,",
                              "but '%s' [\"%s\"] implies that year starts in %s"),
                        name,
                        x,
                        x_month_full,
                        "month_start",
                        month_start,
                        month_start_full))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_date_consistent_with_width_origin <- function(x, name, origin, width) {
    x_year <- format(x, format = "%Y")
    x_year <- as.integer(x_year)
    if ((origin - x_year) %% width != 0L)
        return(gettextf("'%s' [\"%s\"] inconsistent with '%s' [%d] and '%s' [%d]",
                        name,
                        x,
                        "width",
                        width,
                        "origin",
                        origin))
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_dimnames_complete <- function(x, name) {
    dimnames <- dimnames(x)
    names <- names(dimnames)
    dim <- dim(x)
    for (i in seq_along(dimnames)) {
        if (dim[[i]] > 0L) {
            dimnames_i <- dimnames[[i]]
            names_i <- names[[i]]
            if (is.null(dimnames_i))
                return(gettextf("\"%s\" dimension of '%s' does not have dimnames",
                                names_i, name))
            if (any(is.na(dimnames_i)))
                return(gettextf("dimnames for \"%s\" dimension of '%s' have NAs",
                                names_i, name))
            if (!all(nzchar(dimnames_i)))
                return(gettextf("dimnames for \"%s\" dimension of '%s' have blanks",
                                names_i, name))
            is_duplicated <- duplicated(dimnames_i)
            if (any(is_duplicated)) {
                j <- match(TRUE, is_duplicated)
                return(gettextf("dimnames for \"%s\" dimension of '%s' have duplicate [\"%s\"]",
                                names_i, name, dimnames_i[[j]]))
            }
        }
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_dimtypes_mutually_compatible <- function(dimtypes) {
    at_most_one <- c("age",
                     "time",
                     "cohort",
                     "triangle",
                     "iteration",
                     "quantile")
    for (dimtype in at_most_one) {
        if (sum(dimtypes == dimtype) > 1L)
            return(gettextf("two dimensions with dimtype \"%s\"",
                            dimtype))
    }
    if (("iteration" %in% dimtypes) && ("quantile" %in% dimtypes))
        return(gettextf("dimension with dimtype \"%s\" and dimension with dimtype \"%s\"",
                        "iteration", "quantile"))
    TRUE
}

## assumes that 'chk_dimtypes_pairs_suffix'
## has been run on dimtypes and names
## HAS_TESTS
#' @export
#' @rdname composite
chk_dimtypes_pairs_complete <- function(names) {
    vals <- list(c("origin", "_orig$", "destination", "_dest"),
                 c("destination", "_dest$", "origin", "_orig"),
                 c("parent", "_parent$", "child", "_child"),
                 c("child", "_child$", "parent", "_parent"))
    for (val in vals) {
        dimtype <- val[[1L]]
        p_dimtype <- val[[2L]]
        pair <- val[[3L]]
        p_pair <- val[[4L]]
        is_dimtype <- grepl(p_dimtype, names)
        if (any(is_dimtype)) {
            names_pair_implied <- sub(p_dimtype, p_pair, names[is_dimtype])
            is_not_found <- !(names_pair_implied %in% names)
            i_not_found <- match(TRUE, is_not_found, nomatch = 0L)
            if (i_not_found > 0L) {
                return(gettextf(paste("dimension \"%s\" with dimtype \"%s\" does not",
                                      "have paired dimension \"%s\" with dimtype \"%s\""),
                                names[is_dimtype][[i_not_found]],
                                dimtype,
                                names_pair_implied[[i_not_found]],
                                pair))
            }
        }
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_dimtypes_pairs_suffix <- function(dimtypes, names) {
    patterns <- c(origin = "_orig",
                  destination = "_dest",
                  parent = "_parent",
                  child = "_child")
    for (i in seq_along(patterns)) {
        dimtype <- names(patterns)[[i]]
        pattern <- patterns[[i]]
        is_dimtype <- grepl(dimtype, dimtypes)
        is_pattern <- grepl(paste0(pattern, "$"), names)
        i_dimtype_not_pattern <- match(TRUE, is_dimtype & !is_pattern, nomatch = 0L)
        if (i_dimtype_not_pattern > 0L)
            return(gettextf("dimension \"%s\" has dimtype \"%s\" but name does not end with \"%s\"",
                            names[[i_dimtype_not_pattern]], dimtype, pattern))
        i_pattern_not_dimtype <- match(TRUE, is_pattern & !is_dimtype, nomatch = 0L)
        if (i_pattern_not_dimtype > 0L)
            return(gettextf("dimension \"%s\" has name ending with \"%s\" but does not have dimtype \"%s\"",
                            names[[i_pattern_not_dimtype]], pattern, dimtype))
    }
    TRUE   
}
        
## HAS_TESTS
#' @export
#' @rdname composite
chk_ge_break_min_age <- function(age, break_min, date, dob, unit) {
    if (is.null(break_min))
        return(TRUE)
    lt_min <- !is.na(age) & (age < break_min)
    i <- match(TRUE, lt_min, nomatch = 0L)
    if (i > 0L) {
        return(gettextf(paste("'%s' [\"%s\"] and '%s' [\"%s\"] imply an age of %d %ss,",
                              "which is less than '%s' [%d %ss]"),
                        "date",
                        date[[i]],
                        "dob",
                        dob[[i]],
                        age[[i]],
                        unit,
                        "break_min",
                        break_min,
                        unit))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_ge_break_min_date <- function(date, break_min) {
    if (is.null(break_min))
        return(TRUE)
    lt_date_min <- !is.na(date) & (date < break_min)
    i <- match(TRUE, lt_date_min, nomatch = 0L)
    if (i > 0L) {
        return(gettextf("'%s' has value [\"%s\"] that is less than '%s' [\"%s\"]",
                        "date",
                        date[[i]],
                        "break_min",
                        break_min))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_first_day_unit_scalar <- function(x, name, unit) {
    val <- chk_is_length_1(x = x,
                           name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_not_na_scalar(x = x,
                                name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_date_equiv_scalar(x = x,
                                    name = name)
    if (!isTRUE(val))
        return(val)
    x <- as.Date(x)
    val <- chk_member_unit(x = unit,
                           name = "unit")
    if (!isTRUE(val))
        return(val)
    year <- as.integer(format(x, "%Y"))
    unit_is_year <- identical(unit, "year")
    if (unit_is_year) {
        month <- format(x, "%m")
        from <- as.Date(sprintf("%d-%s-01", year, month))
        to <- as.Date(sprintf("%d-%s-01", year + 1L, month))
    }
    else {
        from <- as.Date(sprintf("%d-01-01", year))
        to <- as.Date(sprintf("%d-01-01", year + 1L))
    }
    seq_expected <- seq.Date(from = from,
                             to = to,
                             by = unit)
    is_not_in_seq <- !(x %in% seq_expected)
    if (is_not_in_seq) {
        msg <- gettextf("'%s' [\"%s\"] is not the first day of the %s",
                        name, format(x, "%Y-%m-%d"), unit)
        if (unit_is_year)
            msg <- paste(msg,
                         gettextf("(years assumed to start on the first day of %s)",
                                  format(x, "%B")))
        return(msg)        
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_first_day_unit_vector <- function(x, name, unit) {
    val <- chk_is_not_na_vector(x = x,
                                name = name)
    n <- length(x)
    if (n == 0L)
        return(TRUE)
    val <- chk_is_not_na_vector(x = x,
                                name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_date_equiv_vector(x = x,
                                    name = name)
    if (!isTRUE(val))
        return(val)
    x <- as.Date(x)
    val <- chk_member_unit(x = unit,
                           name = "unit")
    if (!isTRUE(val))
        return(val)
    year <- as.integer(format(x, "%Y"))
    unit_is_year <- identical(unit, "year")
    if (unit_is_year) {
        month <- format(x, "%m")
        month_start <- month[[1L]]
        from <- as.Date(sprintf("%d-%s-01", min(year), month_start))
        to <- as.Date(sprintf("%d-%s-01", max(year) + 1L, month_start))
    }
    else {
        from <- as.Date(sprintf("%d-01-01", min(year)))
        to <- as.Date(sprintf("%d-01-01", max(year) + 1L))
    }
    seq_expected <- seq.Date(from = from,
                             to = to,
                             by = unit)
    is_not_in_seq <- !(x %in% seq_expected)
    i_not_in_seq <- match(TRUE, is_not_in_seq, nomatch = 0L)
    if (i_not_in_seq > 0L) {
        msg <- gettextf("element %d [\"%s\"] of '%s' is not the first day of the %s",
                        i_not_in_seq,
                        format(x[[i_not_in_seq]], "%Y-%m-%d"),
                        name,
                        unit)
        if (unit_is_year)
            msg <- paste(msg,
                         gettextf("(years assumed to start on the first day of %s)",
                                  format(x[[1L]], "%B")))
        return(msg)        
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_first_day_unit_consec <- function(x, name, unit) {
    n <- length(x)
    if (n == 0L)
        return(TRUE)
    val <- chk_is_first_day_unit_vector(x = x,
                                        name = name,
                                        unit = unit)
    if (!isTRUE(val))
        return(val)
    if (n >= 2L) {
        from <- x[[1L]]
        seq_expected <- seq.Date(from = from,     # Calculation using 'seq.Date' relies
                                 by = unit,       # on each date being the first day
                                 length.out = n)  # of the month
        is_not_equal_to_seq <- x != seq_expected
        if (any(is_not_equal_to_seq)) {
            i <- match(TRUE, is_not_equal_to_seq)
            return(gettextf("dates \"%s\" and \"%s\" in '%s' do not belong to consecutive %ss",
                            format(x[[i - 1L]], "%Y-%m-%d"),
                            format(x[[i]], "%Y-%m-%d"),
                            name,
                            unit))
        }
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_ge_scalar <- function(x1, x2, name1, name2) {
    if (!is.na(x1) && !is.na(x2) && (x1 < x2))
        return(gettextf("'%s' [%s] is less than '%s' [%s]",
                        name1, x1, name2, x2))
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_ge_vector <- function(x1, x2, name1, name2) {
    is_lt <- !is.na(x1) & !is.na(x2) & (x1 < x2)
    if (any(is_lt)) {
        i <- match(TRUE, is_lt)
        return(gettextf("element %d of '%s' [%s] is less than element %d of '%s' [%s]",
                        i, name1, x1[[i]], i, name2, x2[[i]]))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_gt_scalar <- function(x1, x2, name1, name2) {
    if (!is.na(x1) && !is.na(x2) && !(x1 > x2))
        return(gettextf("'%s' [%s] is less than or equal to '%s' [%s]",
                        name1, x1, name2, x2))
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_gt_vector <- function(x1, x2, name1, name2) {
    is_lt <- !is.na(x1) & !is.na(x2) & !(x1 > x2)
    i <- match(TRUE, is_lt, nomatch = 0L)    
    if (i > 0L) {
        return(gettextf("element %d of '%s' [%s] is less than or equal to element %d of '%s' [%s]",
                        i, name1, x1[[i]], i, name2, x2[[i]]))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_integer_consec <- function(x, name) {
    val <- chk_is_integer(x = x, name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_not_na_vector(x = x, name = name)
    if (!isTRUE(val))
        return(val)
    if (length(x) >= 2L) {
        diff <- diff(x)
        is_not_one <- diff != 1L
        if (any(is_not_one)) {
            i <- match(TRUE, is_not_one)
            return(gettextf("elements %d [%d] and %d [%d] of '%s' are not consecutive integers",
                            i, x[[i]], i + 1L, x[[i + 1L]], name))
        }
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_logical_flag <- function(x, name) {
    val <- chk_is_logical(x = x, name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_length_1(x = x, name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_not_na_scalar(x = x, name = name)
    if (!isTRUE(val))
        return(val)
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_multiple_of <- function(x1, x2, name1, name2, null_ok) {
    if (is.null(x1)) {
        if (!null_ok)
            return(gettextf("'%s' is %s",
                            name1, "NULL"))
    }
    else {
        if (x1 %% x2 != 0L)
            return(gettextf("'%s' [%s] is not a multiple of '%s' [%s]",
                          name1, x1, name2, x2))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_multiple_of_n <- function(x, name, n, null_ok) {
    if (is.null(x)) {
        if (!null_ok)
            return(gettextf("'%s' is %s",
                            name, "NULL"))
    }
    else {
        if (x %% n != 0L)
            return(gettextf("'%s' [%s] is not a multiple of %d",
                            name, x, n))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname single
chk_is_non_negative_scalar <- function(x, name) {
    val <- chk_is_length_1(x = x,
                           name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_not_na_scalar(x = x,
                                name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_numeric(x = x,
                          name = name)
    if (!isTRUE(val))
        return(val)
    if (x < 0L)
        return(gettextf("'%s' [%s] is negative",
                        name, x))
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname single
chk_is_non_negative_vector <- function(x, name) {
    val <- chk_is_not_na_vector(x = x,
                                name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_numeric(x = x,
                          name = name)
    if (!isTRUE(val))
        return(val)
    is_neg <- x < 0L
    if (any(is_neg)) {
        i <- match(TRUE, is_neg)
        return(gettextf("element %d of '%s' [%s] is negative",
                        i, name, x[[i]]))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname single
chk_is_positive_scalar <- function(x, name) {
    val <- chk_is_length_1(x = x,
                           name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_not_na_scalar(x = x,
                                name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_numeric(x = x,
                          name = name)
    if (!isTRUE(val))
        return(val)
    if (x <= 0L)
        return(gettextf("'%s' [%s] is non-positive",
                        name, x))
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname single
chk_is_positive_vector <- function(x, name) {
    val <- chk_is_not_na_vector(x = x,
                                name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_numeric(x = x,
                          name = name)
    if (!isTRUE(val))
        return(val)
    is_non_pos <- x <= 0L
    if (any(is_non_pos)) {
        i <- match(TRUE, is_non_pos)
        return(gettextf("element %d of '%s' [%s] is non-positive",
                        i, name, x[[i]]))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_string <- function(x, name) {
    val <- chk_is_character(x = x, name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_length_1(x = x, name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_not_na_scalar(x = x, name = name)
    if (!isTRUE(val))
        return(val)
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_strictly_increasing <- function(x, name) {
    val <- chk_is_date_or_numeric(x = x, name = name)
    if (!isTRUE(val))
        return(val)
    val <- chk_is_not_na_vector(x = x, name = name)
    if (!isTRUE(val))
        return(val)
    if (length(x) >= 2L) {
        is_not_incr <- diff(x) <= 0L
        i_not_incr <- match(TRUE, is_not_incr, nomatch = 0L)
        if (i_not_incr > 0L) {
            return(gettextf("'%s' is not strictly increasing : element %d [%s] is greater than or equal to element %d [%s]",
                            name,
                            i_not_incr,
                            x[[i_not_incr]],
                            i_not_incr + 1L,
                            x[[i_not_incr + 1L]]))
        }
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_is_valid_quantile <- function(x, name) {
    p <- "^[0-9.]+%$" # excludes negative numbers
    is_na <- is.na(x)
    is_invalid <- !is_na & !grepl(p, x)
    i_invalid <- match(TRUE, is_invalid, nomatch = 0L)
    if (i_invalid > 0L)
        return(gettextf("\"%s\" is not a valid quantile",
                        x[[i_invalid]]))
    x_num <- sub("%$", "", x)
    x_num <- suppressWarnings(as.numeric(x_num))
    is_invalid <- !is_na & is.na(x_num)
    i_invalid <- match(TRUE, is_invalid, nomatch = 0L)
    if (i_invalid > 0L)
        return(gettextf("\"%s\" is not a valid quantile",
                        x[[i_invalid]]))
    is_gt_100 <- !is_na & (x_num > 100)
    i_gt_100 <- match(TRUE, is_gt_100, nomatch = 0L)
    if (i_gt_100 > 0L)
        return(gettextf("\"%s\" is not a valid quantile : greater than %s",
                        x[[i_gt_100]], "100%"))
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_labels_valid_for_dimtype <- function(labels, dimtype) {
    if (dimtype == "triangle") {
        is_invalid  <- !(labels %in% c("Lower", "Upper"))
        i_invalid <- match(TRUE, is_invalid, nomatch = 0L)
        if (i_invalid > 0L)
            return(gettextf("\"%s\" not a valid label for dimension with dimtype \"%s\"",
                            labels[[i_invalid]], dimtype))
    }
    if (dimtype == "iteration") {
        val <- chk_is_integer_equiv_vector(x = labels,
                                           name = "labels")
        if (!isTRUE(val))
            return(gettextf("invalid label for dimension with dimtype \"%s\" : %s",
                            dimtype, val))
    }
    if (dimtype == "quantile") {
        val <- chk_is_valid_quantile(x = labels,
                                     name = "labels")
        if (!isTRUE(val))
            return(gettextf("invalid label for dimension with dimtype \"%s\" : %s",
                            dimtype, val))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_length_same <- function(x1, x2, name1, name2) {
    n1 <- length(x1)
    n2 <- length(x2)
    if (n1 != n2)
        return(gettextf("length of '%s' [%d] not equal to length of '%s' [%d]",
                        name1, n1, name2, n2))
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_length_same_or_1 <- function(x1, x2, name1, name2) {
    n1 <- length(x1)
    n2 <- length(x2)
    if (n1 == 0L)
        return(gettextf("'%s' has length %d",
                        name1, 0L))
    if (n2 == 0L)
        return(gettextf("'%s' has length %d",
                        name2, 0L))
    if (n1 == n2)
        return(TRUE)
    if ((n1 == 1L) || (n2 == 1L))
        return(TRUE)
    gettextf("'%s' has length %d and '%s' has length %d : should have same lengths, or one should have length %d",
             name1, n1, name2, n2, 1L)
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_lt_break_max_age <- function(age, break_max, date, dob, unit) {
    if (is.null(break_max))
        return(TRUE)
    ge_max <- !is.na(age) & (age >= break_max)
    i <- match(TRUE, ge_max, nomatch = 0L)
    if (i > 0L) {
        return(gettextf(paste("'%s' [\"%s\"] and '%s' [\"%s\"] imply an age of %d %ss,",
                              "which is greater than or equal to '%s' [%d %ss]"),
                        "date",
                        date[[i]],
                        "dob",
                        dob[[i]],
                        age[[i]],
                        unit,
                        "break_max",
                        break_max,
                        unit))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_lt_break_max_date <- function(date, break_max) {
    if (is.null(break_max))
        return(TRUE)
    ge_date_max <- !is.na(date) & (date >= break_max)
    i <- match(TRUE, ge_date_max, nomatch = 0L)
    if (i > 0L) {
        return(gettextf("'%s' has value [\"%s\"] that is greater than or equal to '%s' [\"%s\"]",
                        "date",
                        date[[i]],
                        "break_max",
                        break_max))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_names_complete <- function(x, name) {
    nms <- names(x)
    if ((length(x) > 0L) && is.null(nms))
        return(gettextf("'%s' does not have names",
                        name))
    if (any(is.na(nms)))
        return(gettextf("names for '%s' have NAs",
                        name))
    if (!all(nzchar(nms)))
        return(gettextf("names for '%s' have blanks",
                        name))
    is_duplicated <- duplicated(nms)
    if (any(is_duplicated)) {
        i <- match(TRUE, is_duplicated)
        return(gettextf("names for '%s' have duplicate [\"%s\"]",
                        name, nms[[i]]))
    }
    TRUE
}

## HAS_TESTS
#' @export
#' @rdname composite
chk_names_dimnames_complete <- function(x, name) {
    nms <- names(dimnames(x))
    if (any(is.na(nms)))
        return(gettextf("names for dimnames of '%s' have NAs",
                        name))
    if (!all(nzchar(nms)))
        return(gettextf("names for dimnames of '%s' have blanks",
                        name))
    is_duplicated <- duplicated(nms)
    if (any(is_duplicated)) {
        i <- match(TRUE, is_duplicated)
        return(gettextf("names for dimnames of '%s' have duplicate [\"%s\"]",
                        name, nms[[i]]))
    }
    TRUE
}

#' @export
#' @rdname composite
chk_quantiles_increasing <- function(x, name) {
    p <- "%$"
    numbers <- sub(p, "", x)
    numbers <- as.numeric(numbers)
    if (length(x) >= 2L) {
        is_not_incr <- diff(numbers) <= 0L
        i_not_incr <- match(TRUE, is_not_incr, nomatch = 0L)
        if (i_not_incr > 0L) {
            return(gettextf(paste("'%s' is not strictly increasing : element %d [%s]",
                                  "is greater than or equal to element %d [%s]"),
                            name,
                            i_not_incr,
                            x[[i_not_incr]],
                            i_not_incr + 1L,
                            x[[i_not_incr + 1L]]))
        }
    }
    TRUE
}


## HAS_TESTS
#' @export
#' @rdname composite
chk_trans_list <- function(x, name) {
    if (!is.list(x))
        stop(gettextf("'%s' is not a list",
                      name))
    val <- chk_names_complete(x = x,
                              name = name)
    if (!isTRUE(val))
        return(val)
    names_x <- names(x)
    for (i in seq_along(x)) {
        element <- x[[i]]
        name_element <- names_x[[i]]
        if (is.null(element)) {
            next
        }
        else if (is.character(element)) {
            if (any(is.na(element)))
                return(gettextf("element \"%s\" of '%s' has NAs",
                                name_element, name))
            if (any(!nzchar(element)))
                return(gettextf("element \"%s\" of '%s' has blanks",
                                name_element, name))
            if (any(duplicated(element)))
                return(gettextf("element \"%s\" of '%s' has duplicates",
                                name_element, name))
            dest_not_found <- match(element, names_x, nomatch = 0L) == 0L
            if (any(dest_not_found)) {
                i_not_found <- match(TRUE, dest_not_found)
                return(gettextf(paste("value \"%s\" in element \"%s\" of '%s' invalid :",
                                      "\"%s\" is not the name of an element of '%s'"),
                                element[[i_not_found]],
                                name_element,
                                name,
                                element[[i_not_found]],
                                name))
            }
        }
        else {
            return(gettextf("element \"%s\" of '%s' has class \"%s\"",
                            name_element, name, class(element)))
        }
    }
    TRUE    
}

